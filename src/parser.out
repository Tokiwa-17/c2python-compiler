Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ELLIPSIS

Grammar

Rule 0     S' -> empty
Rule 1     empty -> <empty>
Rule 2     primary_expression -> IDENTIFIER
Rule 3     primary_expression -> CONSTANT
Rule 4     primary_expression -> STRING_LITERAL
Rule 5     primary_expression -> ( expression )
Rule 6     postfix_expression -> primary_expression
Rule 7     postfix_expression -> postfix-expression [ expression ]
Rule 8     postfix_expression -> postfix-expression ( )
Rule 9     postfix_expression -> postfix-expression ( argument-expression-listopt )
Rule 10    postfix_expression -> postfix-expression . IDENTIFIER
Rule 11    postfix_expression -> postfix-expression PTR_OP IDENTIFIER
Rule 12    postfix_expression -> postfix-expression INC_DEC
Rule 13    postfix_expression -> ( type_name ) { initializer_list }
Rule 14    postfix_expression -> ( type_name ) { initializer_list , }
Rule 15    argument_expression_list -> assignment_expression
Rule 16    argument_expression_list -> argument-expression-list , assignment-expression
Rule 17    unary_expression -> postfix_expression
Rule 18    unary_expression -> INC_DEC unary_expression
Rule 19    unary_expression -> unary_operator cast_expression
Rule 20    unary_expression -> SIZEOF unary_expression
Rule 21    unary_expression -> SIZEOF ( type_name )
Rule 22    unary_operator -> &
Rule 23    unary_operator -> *
Rule 24    unary_operator -> +
Rule 25    unary_operator -> -
Rule 26    unary_operator -> ~
Rule 27    unary_operator -> !
Rule 28    cast_expression -> unary_expression
Rule 29    cast_expression -> ( type_name ) cast_expression
Rule 30    multiplicative_expression -> cast_expression
Rule 31    multiplicative_expression -> multiplicative_expression * cast_expression
Rule 32    multiplicative_expression -> multiplicative_expression / cast_expression
Rule 33    multiplicative_expression -> multiplicative_expression % cast_expression
Rule 34    additive_expression -> multiplicative_expression
Rule 35    additive_expression -> additive_expression + multiplicative_expression
Rule 36    additive_expression -> additive_expression - multiplicative-expression
Rule 37    shift-expression -> additive_expression
Rule 38    shift-expression -> shift_expression SHIFT_OP additive_expression
Rule 39    relational_expression -> shift_expression
Rule 40    relational_expression -> relational_expression < shift_expression
Rule 41    relational_expression -> relational_expression > shift_expression
Rule 42    relational_expression -> relational_expression GE_LE shift_expression
Rule 43    equality_expression -> relational_expression
Rule 44    equality_expression -> equality_expression EQ_NE relational_expression
Rule 45    and_expression -> equality_expression
Rule 46    and_expression -> and_expression & equality_expression
Rule 47    exclusive_or_expression -> and_expression
Rule 48    exclusive_or_expression -> exclusive_or_expression ^ and_expression
Rule 49    inclusive_or_expression -> exclusive_or_expression
Rule 50    inclusive_or_expression -> inclusive_or_expression | exclusive_or_expression
Rule 51    logical_and_expression -> inclusive_or_expression
Rule 52    logical_and_expression -> logical_and_expression AND_OP inclusive_or_expression
Rule 53    logical_or_expression -> logical_and_expression
Rule 54    logical_or_expression -> logical_or_expression OR_OP logical_and_expression
Rule 55    conditional_expression -> logical_or_expression
Rule 56    conditional_expression -> logical_or_expression ? expression : conditional_expression
Rule 57    assignment_expression -> conditional_expression
Rule 58    assignment_expression -> unary_expression assignment_operator assignment_expression
Rule 59    assignment_operator -> ASSIGN_OP
Rule 60    declaration -> declaration_specifiers ;
Rule 61    declaration -> declaration_specifiers init_declarator_list ;
Rule 62    declaration_specifiers -> storage_class_specifier
Rule 63    declaration_specifiers -> storage_class_specifier declaration_specifiers
Rule 64    declaration_specifiers -> type_specifier
Rule 65    declaration_specifiers -> type_specifier declaration_specifiers
Rule 66    declaration_specifiers -> type_qualifier
Rule 67    declaration_specifiers -> type_qualifier declaration_specifiers
Rule 68    declaration_specifiers -> function_specifier
Rule 69    declaration_specifiers -> function_specifier declaration_specifiers
Rule 70    init_declarator_list -> init_declarator
Rule 71    init_declarator_list -> init_declarator_list , init_declarator
Rule 72    init_declarator -> declarator
Rule 73    init_declarator -> declarator = initializer
Rule 74    storage_class_specifier -> TYPEDEF
Rule 75    storage_class_specifier -> EXTERN
Rule 76    storage_class_specifier -> STATIC
Rule 77    storage_class_specifier -> AUTO
Rule 78    storage_class_specifier -> REGISTER
Rule 79    type_specifier -> VOID
Rule 80    type_specifier -> CHAR
Rule 81    type_specifier -> SHORT
Rule 82    type_specifier -> INT
Rule 83    type_specifier -> LONG
Rule 84    type_specifier -> FLOAT
Rule 85    type_specifier -> DOUBLE
Rule 86    type_specifier -> SIGNED
Rule 87    type_specifier -> UNSIGNED
Rule 88    type_specifier -> BOOL
Rule 89    type_specifier -> struct_or_union_specifier
Rule 90    type_specifier -> enum_specifier
Rule 91    type_specifier -> typedef_name
Rule 92    struct_or_union_specifier -> struct_or_union { struct_declaration_list }
Rule 93    struct_or_union_specifier -> struct_or_union IDENTIFIER { struct_declaration_list }
Rule 94    struct_or_union_specifier -> struct_or_union IDENTIFIER
Rule 95    struct_or_union -> STRUCT
Rule 96    struct_or_union -> UNION
Rule 97    struct_declaration_list -> struct_declaration
Rule 98    struct_declaration_list -> struct_declaration_list struct_declaration
Rule 99    struct_declaration -> specifier_qualifier_list struct_declarator_list ;
Rule 100   specifier_qualifier_list -> type_specifier
Rule 101   specifier_qualifier_list -> type_specifier specifier_qualifier_list
Rule 102   specifier_qualifier_list -> type_qualifeir
Rule 103   specifier_qualifier_list -> type_qualifeir specifier_qualifier_list
Rule 104   struct_declarator_list -> struct_declarator
Rule 105   struct_declarator_list -> struct_declarator_list struct_declarator
Rule 106   struct_declarator -> declarator
Rule 107   struct_declarator -> : constant_expression
Rule 108   struct_declarator -> declarator : constant_expression
Rule 109   enum_specifier -> ENUM { enumerator_list }
Rule 110   enum_specifier -> ENUM IDENTIFIER { enumerator_list }
Rule 111   enum_specifier -> ENUM { enumerator_list , }
Rule 112   enum_specifier -> ENUM IDENTIFIER { enumerator_list , }
Rule 113   enum_specifier -> ENUM IDENTIFIER
Rule 114   enumerator_list -> enumerator
Rule 115   enumerator_list -> enumerator_list enumerator
Rule 116   enumerator -> enumeration_constant
Rule 117   enumerator -> enumeration_constant = constant_expression
Rule 118   type_qualifier -> CONST
Rule 119   type_qualifier -> RESTRICT
Rule 120   type_qualifier -> VOLATILE
Rule 121   function_specifier -> INLINE
Rule 122   statement -> labeled_statement
Rule 123   statement -> compound_statement
Rule 124   statement -> expression_statement
Rule 125   statement -> selection_statement
Rule 126   statement -> iteration_statement
Rule 127   statement -> jump_statement
Rule 128   labeled_statement -> IDENTIFIER : statement
Rule 129   labeled_statement -> CASE constant_expression : statement
Rule 130   labeled_statement -> DEFAULT : statement
Rule 131   compound_statement -> { }
Rule 132   compound_statement -> { block_item_list }
Rule 133   block_item_list -> block_item
Rule 134   block_item_list -> block_item_list block_item
Rule 135   block_item -> declaration
Rule 136   block_item -> statement
Rule 137   expression_statement -> empty
Rule 138   expression_statement -> expression
Rule 139   selection_statement -> IF ( expression ) statement
Rule 140   selection_statement -> IF ( expression ) ELSE statement
Rule 141   selection_statement -> SWITCH ( expression ) statement
Rule 142   iteration_statement -> WHILE ( expression ) statement
Rule 143   iteration_statement -> DO statement WHILE ( expression ) ;
Rule 144   iteration_statement -> FOR ( ; ; ) statement
Rule 145   iteration_statement -> FOR ( expression ; ; ) statement
Rule 146   iteration_statement -> FOR ( ; expression ; ) statement
Rule 147   iteration_statement -> FOR ( ; ; expression ) statement
Rule 148   iteration_statement -> FOR ( expression ; expression ; ) statement
Rule 149   iteration_statement -> FOR ( ; expression ; expression ) statement
Rule 150   iteration_statement -> FOR ( expression ; ; expression ) statement
Rule 151   iteration_statement -> FOR ( expression ; expression ; expression ) statement
Rule 152   iteration_statement -> FOR ( declaration ; ) statement
Rule 153   iteration_statement -> FOR ( declaration ; expression ) statement
Rule 154   iteration_statement -> FOR ( declaration expression ; ) statement
Rule 155   iteration_statement -> FOR ( declaration expression ; expression ) statement
Rule 156   jump_statement -> GOTO IDENTIFIER ;
Rule 157   jump_statement -> CONTINUE ;
Rule 158   jump_statement -> BREAK ;
Rule 159   jump_statement -> RETURN ;
Rule 160   jump_statement -> RETURN expression ;
Rule 161   translation_unit -> external_declaration
Rule 162   translation_unit -> translation_unit external_declaration
Rule 163   external_declaration -> function_definition
Rule 164   external_declaration -> declaration
Rule 165   function_definition -> declaration_specifiers declarator declaration_list compound_statement
Rule 166   function_definition -> declaration_specifiers declarator compound_statement
Rule 167   declaration_list -> declaration
Rule 168   declaration_list -> declaration_list declaration

Terminals, with rules where they appear

!                    : 27
%                    : 33
&                    : 22 46
(                    : 5 8 9 13 14 21 29 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155
)                    : 5 8 9 13 14 21 29 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155
*                    : 23 31
+                    : 24 35
,                    : 14 16 71 111 112
-                    : 25 36
.                    : 10
/                    : 32
:                    : 56 107 108 128 129 130
;                    : 60 61 99 143 144 144 145 145 146 146 147 147 148 148 149 149 150 150 151 151 152 153 154 155 156 157 158 159 160
<                    : 40
=                    : 73 117
>                    : 41
?                    : 56
AND_OP               : 52
ASSIGN_OP            : 59
AUTO                 : 77
BOOL                 : 88
BREAK                : 158
CASE                 : 129
CHAR                 : 80
CONST                : 118
CONSTANT             : 3
CONTINUE             : 157
DEFAULT              : 130
DO                   : 143
DOUBLE               : 85
ELLIPSIS             : 
ELSE                 : 140
ENUM                 : 109 110 111 112 113
EQ_NE                : 44
EXTERN               : 75
FLOAT                : 84
FOR                  : 144 145 146 147 148 149 150 151 152 153 154 155
GE_LE                : 42
GOTO                 : 156
IDENTIFIER           : 2 10 11 93 94 110 112 113 128 156
IF                   : 139 140
INC_DEC              : 12 18
INLINE               : 121
INT                  : 82
LONG                 : 83
OR_OP                : 54
PTR_OP               : 11
REGISTER             : 78
RESTRICT             : 119
RETURN               : 159 160
SHIFT_OP             : 38
SHORT                : 81
SIGNED               : 86
SIZEOF               : 20 21
STATIC               : 76
STRING_LITERAL       : 4
STRUCT               : 95
SWITCH               : 141
TYPEDEF              : 74
UNION                : 96
UNSIGNED             : 87
VOID                 : 79
VOLATILE             : 120
WHILE                : 142 143
[                    : 7
]                    : 7
^                    : 48
error                : 
{                    : 13 14 92 93 109 110 111 112 131 132
|                    : 50
}                    : 13 14 92 93 109 110 111 112 131 132
~                    : 26

Nonterminals, with rules where they appear

additive_expression  : 35 36 37 38
and_expression       : 46 47 48
argument-expression-list : 16
argument-expression-listopt : 9
argument_expression_list : 
assignment-expression : 16
assignment_expression : 15 58
assignment_operator  : 58
block_item           : 133 134
block_item_list      : 132 134
cast_expression      : 19 29 30 31 32 33
compound_statement   : 123 165 166
conditional_expression : 56 57
constant_expression  : 107 108 117 129
declaration          : 135 152 153 154 155 164 167 168
declaration_list     : 165 168
declaration_specifiers : 60 61 63 65 67 69 165 166
declarator           : 72 73 106 108 165 166
empty                : 137 0
enum_specifier       : 90
enumeration_constant : 116 117
enumerator           : 114 115
enumerator_list      : 109 110 111 112 115
equality_expression  : 44 45 46
exclusive_or_expression : 48 49 50
expression           : 5 7 56 138 139 140 141 142 143 145 146 147 148 148 149 149 150 150 151 151 151 153 154 155 155 160
expression_statement : 124
external_declaration : 161 162
function_definition  : 163
function_specifier   : 68 69
inclusive_or_expression : 50 51 52
init_declarator      : 70 71
init_declarator_list : 61 71
initializer          : 73
initializer_list     : 13 14
iteration_statement  : 126
jump_statement       : 127
labeled_statement    : 122
logical_and_expression : 52 53 54
logical_or_expression : 54 55 56
multiplicative-expression : 36
multiplicative_expression : 31 32 33 34 35
postfix-expression   : 7 8 9 10 11 12
postfix_expression   : 17
primary_expression   : 6
relational_expression : 40 41 42 43 44
selection_statement  : 125
shift-expression     : 
shift_expression     : 38 39 40 41 42
specifier_qualifier_list : 99 101 103
statement            : 128 129 130 136 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155
storage_class_specifier : 62 63
struct_declaration   : 97 98
struct_declaration_list : 92 93 98
struct_declarator    : 104 105
struct_declarator_list : 99 105
struct_or_union      : 92 93 94
struct_or_union_specifier : 89
translation_unit     : 162
type_name            : 13 14 21 29
type_qualifeir       : 102 103
type_qualifier       : 66 67
type_specifier       : 64 65 100 101
typedef_name         : 91
unary_expression     : 18 20 28 58
unary_operator       : 19

