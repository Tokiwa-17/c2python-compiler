#编译原理小组实验实验报告

## 1. 实验内容

实现了从C语言到Python语言的简单编译器，支持下列C语言特性：

1. `#include`,`#define`预处理指令
2. 简单的变量作用域（全局变量/局部变量）
3. 选择语句（if-else）、循环语句（for、while）
4. 结构体和数组（非指针）
5. 浮点数、科学计数法

且实现了KMP字符串匹配、回文检测、插入排序等示例程序的翻译。

## 2. 实验环境

**操作系统：**Windows
		**编程语言：**Python
		**第三方工具：**PLY(Python  Lex-Yacc)

## 3. 实验原理

C语言源文件经过`lex.py`词法分析得到`token`流，再经过`yacc.py`语法分析得到抽象语法树，在`interpreter.py`程序中进行语义分析、中间代码生成，并最终输出目标代码Python源文件。

* **词法分析：**

  我们使用ply库中的lex模块实现词法分析。包含了C99标准文档中的保留字，对于同类的其它词素进行整理得到了合乎规范的tokens并用正则表达式书写了模式。同时，注释、换行和部分错误处理也在词法分析阶段实现。

* **语法分析：**

  使用ply库中yacc模块实现，整体参考了C99标准文档中的语法规则，自底向上的完成语法分析过程。该过程中会进行抽象语法树(`ast_.py`)的构造，每当一条文法产生式被匹配，便会调用`ASTInternalNode`为抽象语法树添加一颗内部节点，该节点包含了词法单元名和其子节点列表；终结符被匹配时会添加新的叶子节点。在完成语法分析后，会得到源代码的抽象语法树并作为下一步的参数。

* **语义分析：**

  我们使用了语法制导的语义处理，为每个抽象语法树节点设置了code的综合属性，表示每个节点翻译成后端代码的结果，根节点的code属性就是翻译的结果。

  注意到C99文档中的产生式为最右推导，所以为了保证翻译后的后端代码和翻译前的前端代码保持声明、定义顺序的一致，首先对扫描得到的声明列表和定义列表反序，然后先后对变量声明和函数声明的节点进行自下而上的递归遍历生成代码顺序加到后端代码列表中。

  下面是具体的细节：

  1. 首先根据以下产生式提取代码中的声明和函数定义：

    >$translation\_unit  \rightarrow external\_declaration$​
    >
    >$translation\_unit  \rightarrow translation\_unit \quad external\_declaration$

    然后分离声明列表中的全局变量声明(定义)和函数声明，忽略函数声明，提取所有的全局变量记录到变量表中。

  2. 然后`generate_code`函数对每个节点递归自下而上计算综合属性`code`，通过`code_translation`函数实现。

     `code_tranlation`是与主要产生式关联的语义规则的集合，描述了具体如何计算code属性。

  3. 根据声明的语法产生式判断语句是否是函数声明

     ![image-20211221224258117](C:\Users\ylf\AppData\Roaming\Typora\typora-user-images\image-20211221224258117.png)

     只匹配`direct-declarator (*)`类型。

  4. 实现简单的作用域：在函数定义中，首先deepcopy符号表，然后进到作用域后对抽象语法树的叶子节点查看是否已经有相同名字的变量，将其重命名

  5. 生成后端代码后使用yapf格式化代码

## 3. 功能说明

* 预处理

  `#define`类型预处理会在python代码中定义相应宏，`#include`类型预处理若参数为C标准库，则在python代码中包含预先使用python语言写好的C标准库替代文件，这些文件中实现了部分常用功能；若参数为自定义文件，则将对应文件的所有代码复制到源代码相应位置。

* 函数

  编译器可以识别源代码中的`main`函数，并将其作为程序入口点。对于其他函数，语义分析阶段会优先找到所有函数的声明和定义，并翻译成对应的python代码放到全局变量之后。

* 变量作用域

  **TODO：其它变量作用域不确定是否实现**

  编译器会记录下所有的全局变量，并在生成python代码时，于每个函数前声明这些全局变量，以确保变量拥有正确的作用域

* 分支/循环

  `if-else`格式和`while`格式在python中都容易翻译成对应格式，对于C语言中的`for`循环，由于其用法和Python有较大差异，因此被翻译成等价的`while`语句。

* 数组

  编译器支持不涉及指针的C语言数组定义，这些数组被翻译成了Python中的列表。数组的声明使用`name = [None]*length`形式翻译。数组下标的使用形式于Python列表保持一致。

* 结构体

  将C的结构体翻译为了Python的类，即`struct A{...}`被翻译成`class A: ...`。对于其中结构体的嵌套也正确翻译成了Python中语法格式。对于结构体数组，使用了`struct_list = [struct_name() for i in rage(list_length)]`的方式创建。

* 缩进

  使用嵌套列表来存储语法分析树的节点，每一层嵌套都代表了一层缩进。

## 4.难点与创新

1. C语言标准库的实现：使用预先写好的对应python文件解决。
2. 变量作用域问题：在每个函数中声明全局变量以确保正确。
3. 缩进问题：使用嵌套列表方式，以嵌套层数表示目标代码的缩进。
4. 目标代码风格：手写了`lint`函数以确保目标代码优美。yapf
5. for循环问题：将C风格的for循环翻译为python中等价的while循环。

## 5. 小组分工

**TODO**

